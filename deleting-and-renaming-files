Let's say that you've decided
to clean up some old scripts and want to remove them from your repository. Or you've done some refactoring, which
makes that particular file, obsolete. You can remove files from your repository
with the git rm command, which will stop the file from being tracked by
git and remove it from the git directory. File removals go through the same
general workflow that we've seen. So you'll need to write a commit
message as to why you've deleted them. Let's try this out in our checks
repository that contains a file we decided we actually don't want. Well first look the contents
of the directory with ls, then delete the file with git rm,
then check the contents with ls again, and finally check the status with git status. So, we see that by calling git rm, the
file was deleted from the directory, and the change was also staged to be
committed in our next commit. Let's do that now,
by calling git commit and sending a message indicating that
we've deleted the unneeded file. As usual, we get a bunch of
stats when we do the commit. Check out all the deletions that reported. These are all lines in the file
that are no longer there. And it states the file itself was deleted. What if you have a file that
isn't accurately named? This can happen. For example, if you start writing a script
that you thought would only do one thing, and then expands to cover more use cases. Or conversely, if you named your script
thinking that it would be very generic, but it ends up being more specific. You can use the git mv command to
rename files in the repository. Let's rename our existing script
to check_free_space.py and check what git status
has to say about that. The status shows us that the file was
renamed and clearly displays the old and new names. As with the previous example,
the change is staged, but not committed. Let's commit it by calling
git commit once again. The git mv command works in a similar
way to the mv command on Linux and so can be used for
both moving and renaming. If our repository included
more directories in it, we can use the same git mv command
to move files between directories. As you can probably tell from
our examples, the output of git status is a super useful tool to help
us know what's up with our files. It shows us which files have tracked or
untracked changes, and which files were added,
modified, deleted or renamed. It's important that the output of
these commands stays relevant to what we're doing. If we have a long list of untracked files, we might lose an important
change in the noise. If there are files that get automatically
generated by our scripts, or our operating system generates artifacts
that we don't want in our repo, we'll want to ignore them so that they don't
add noise to the output of git status. To do this, we can use the gitignore file. Inside this file, we'll specify rules
to tell git which files to skip for the current repo. For example,
if we're working on an OSX computer, we'll probably want to ignore
the dot DS store file, which is automatically generated
by the operating system. To do this, we'll create a .gitignore
file containing the name of this file. Remember that the dot prefix
in a Unix-like file system indicates that the file or directory is hidden and won't show up
when you do the normal directory listing. That's why we have to use
ls-la to see all files. We've added a gitignore file to our
repo but we haven't committed it yet. This file needs to get tracked just
like the rest of the files in the repo. Let's add it now. Looks great. We've learned a lot of new commands and techniques related to git
in these past videos. If anything isn't clear at this point,
now's a good time to experiment on your own and share any challenges
in the discussion forums. Coming up, we put together a cheat sheet
listing all the new commands and options. After that,
a quiz let you practice these concepts. Now, go on, get.
